/* src/VideoCanvas.svelte generated by Svelte v3.23.2 */
import {
	SvelteComponent,
	binding_callbacks,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "https://jcc2303.github.io/sign-language/web_modules/svelte/internal.js";

import { onMount } from "https://jcc2303.github.io/sign-language/web_modules/svelte.js";

function create_fragment(ctx) {
	let canvas_1;

	return {
		c() {
			canvas_1 = element("canvas");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[5](canvas_1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(canvas_1);
			/*canvas_1_binding*/ ctx[5](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { video } = $$props;
	let { predictions } = $$props;
	let { canvas } = $$props;
	let { ctx } = $$props;
	let { videoWidth, videoHeight } = video;

	let fingerLookupIndices = {
		thumb: [0, 1, 2, 3, 4],
		indexFinger: [0, 5, 6, 7, 8],
		middleFinger: [0, 9, 10, 11, 12],
		ringFinger: [0, 13, 14, 15, 16],
		pinky: [0, 17, 18, 19, 20]
	};

	const renderVideo = async () => {
		await ctx.drawImage(video, 0, 0, videoWidth, videoHeight, 0, 0, canvas.width, canvas.height);
	};

	const drawPoint = (ctx, y, x, r) => {
		ctx.beginPath();
		ctx.arc(x, y, r, 0, 2 * Math.PI);
		ctx.fill();
	};

	const drawPath = (ctx, points, closePath) => {
		const region = new Path2D();
		region.moveTo(points[0][0], points[0][1]);

		for (let i = 1; i < points.length; i++) {
			const point = points[i];
			region.lineTo(point[0], point[1]);
		}

		if (closePath) {
			region.closePath();
		}

		ctx.stroke(region);
	};

	const drawKeypoints = (ctx, keypoints) => {
		const keypointsArray = keypoints;

		for (let i = 0; i < keypointsArray.length; i++) {
			const y = keypointsArray[i][0];
			const x = keypointsArray[i][1];
			drawPoint(ctx, x - 2, y - 2, 3);
		}

		const fingers = Object.keys(fingerLookupIndices);

		for (let i = 0; i < fingers.length; i++) {
			const finger = fingers[i];
			const points = fingerLookupIndices[finger].map(idx => keypoints[idx]);
			drawPath(ctx, points, false);
		}
	};

	const drawPredictions = predictions => {
		if (predictions.length > 0) {
			const result = predictions[0].landmarks;
			drawKeypoints(ctx, result, predictions[0].annotations);
		}
	};

	onMount(() => {
		$$invalidate(0, canvas.width = videoWidth, canvas);
		$$invalidate(0, canvas.height = videoHeight, canvas);
		$$invalidate(1, ctx = canvas.getContext("2d"));
		ctx.clearRect(0, 0, videoWidth, videoHeight);
		$$invalidate(1, ctx.strokeStyle = "red", ctx);
		$$invalidate(1, ctx.fillStyle = "red", ctx);
		ctx.translate(canvas.width, 0);
		ctx.scale(-1, 1);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	$$self.$set = $$props => {
		if ("video" in $$props) $$invalidate(2, video = $$props.video);
		if ("predictions" in $$props) $$invalidate(3, predictions = $$props.predictions);
		if ("canvas" in $$props) $$invalidate(0, canvas = $$props.canvas);
		if ("ctx" in $$props) $$invalidate(1, ctx = $$props.ctx);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*predictions*/ 8) {
			$: if (predictions) {
				drawPredictions(predictions);
			}
		}
	};

	return [canvas, ctx, video, predictions, renderVideo, canvas_1_binding];
}

class VideoCanvas extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			video: 2,
			predictions: 3,
			canvas: 0,
			ctx: 1,
			renderVideo: 4
		});
	}

	get renderVideo() {
		return this.$$.ctx[4];
	}
}

export default VideoCanvas;