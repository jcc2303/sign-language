/* src/Scatter.svelte generated by Svelte v3.23.2 */
import {
	SvelteComponent,
	binding_callbacks,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "https://jcc2303.github.io/sign-language/web_modules/svelte/internal.js";

import { onMount } from "https://jcc2303.github.io/sign-language/web_modules/svelte.js";
import * as three from "https://jcc2303.github.io/sign-language/web_modules/three.js";
import * as ScatterGLX from "https://jcc2303.github.io/sign-language/web_modules/scatter-gl.js";

function create_fragment(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[3](div);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[3](null);
		}
	};
}

const VIDEO_WIDTH = 640;
const VIDEO_HEIGHT = 500;

function instance($$self, $$props, $$invalidate) {
	const { default: { ScatterGL } } = ScatterGLX;
	let { predictions = [] } = $$props;
	let { renderPointcloud } = $$props;
	let glContainer;
	let scatterGLHasInitialized = false;
	let scatterGL;

	onMount(async () => {
		if (renderPointcloud) {
			$$invalidate(0, glContainer.style = `width: ${VIDEO_WIDTH}px; height: ${VIDEO_HEIGHT}px;`, glContainer);

			scatterGL = new ScatterGL(glContainer,
			{
					rotateOnStart: false,
					selectEnabled: false
				});
		}
	});

	let fingerLookupIndices = {
		thumb: [0, 1, 2, 3, 4],
		indexFinger: [0, 5, 6, 7, 8],
		middleFinger: [0, 9, 10, 11, 12],
		ringFinger: [0, 13, 14, 15, 16],
		pinky: [0, 17, 18, 19, 20]
	};

	// These anchor points allow the hand pointcloud to resize according to its
	// position in the input.
	const ANCHOR_POINTS = [
		[0, 0, 0],
		[0, -VIDEO_HEIGHT, 0],
		[-VIDEO_WIDTH, 0, 0],
		[-VIDEO_WIDTH, -VIDEO_HEIGHT, 0]
	];

	const drawPredictions = predictions => {
		if (predictions.length > 0) {
			const result = predictions[0].landmarks;

			if (renderPointcloud === true && scatterGL != null) {
				const pointsData = result.map(point => {
					return [-point[0], -point[1], -point[2]];
				});

				const dataset = new ScatterGL.Dataset([...pointsData, ...ANCHOR_POINTS]);

				if (!scatterGLHasInitialized) {
					scatterGL.render(dataset);
					const fingers = Object.keys(fingerLookupIndices);
					scatterGL.setSequences(fingers.map(finger => ({ indices: fingerLookupIndices[finger] })));
					scatterGL.setPointColorer(index => index < pointsData.length ? "steelblue" : "white");
					scatterGLHasInitialized = true;
				}

				scatterGL.updateDataset(dataset);
			}
		}
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			glContainer = $$value;
			$$invalidate(0, glContainer);
		});
	}

	$$self.$set = $$props => {
		if ("predictions" in $$props) $$invalidate(1, predictions = $$props.predictions);
		if ("renderPointcloud" in $$props) $$invalidate(2, renderPointcloud = $$props.renderPointcloud);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*predictions*/ 2) {
			$: if (predictions) {
				drawPredictions(predictions);
			}
		}
	};

	return [glContainer, predictions, renderPointcloud, div_binding];
}

class Scatter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { predictions: 1, renderPointcloud: 2 });
	}
}

export default Scatter;