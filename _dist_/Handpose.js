/* src/Handpose.svelte generated by Svelte v3.23.2 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "https://jcc2303.github.io/sign-language/web_modules/svelte/internal.js";

import * as handpose from "https://jcc2303.github.io/sign-language/web_modules/@tensorflow-models/handpose.js";
import * as tfjsWasm from "https://jcc2303.github.io/sign-language/web_modules/@tensorflow/tfjs-backend-wasm.js";
import * as tf from "https://jcc2303.github.io/sign-language/web_modules/@tensorflow/tfjs.js";
import { version_wasm } from "https://jcc2303.github.io/sign-language/web_modules/@tensorflow/tfjs-backend-wasm.js";
import Stats from "https://jcc2303.github.io/sign-language/web_modules/stats.js";
import * as three from "https://jcc2303.github.io/sign-language/web_modules/three.js";
import CameraVideo from "./CameraVideo.js";
import VideoCanvas from "./VideoCanvas.js";
import BackendChooser from "./BackendChooser.js";
import Scatter from "./Scatter.js";

function create_if_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = `${/*info*/ ctx[6]}`;
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (107:2) {#if videoLoaded}
function create_if_block(ctx) {
	let div1;
	let div0;
	let videocanvas;
	let updating_predictions;
	let t;
	let scatter;
	let updating_predictions_1;
	let current;

	function videocanvas_predictions_binding(value) {
		/*videocanvas_predictions_binding*/ ctx[14].call(null, value);
	}

	let videocanvas_props = { video: /*video*/ ctx[2] };

	if (/*predictions*/ ctx[4] !== void 0) {
		videocanvas_props.predictions = /*predictions*/ ctx[4];
	}

	videocanvas = new VideoCanvas({ props: videocanvas_props });
	/*videocanvas_binding*/ ctx[13](videocanvas);
	binding_callbacks.push(() => bind(videocanvas, "predictions", videocanvas_predictions_binding));

	function scatter_predictions_binding(value) {
		/*scatter_predictions_binding*/ ctx[15].call(null, value);
	}

	let scatter_props = {
		renderPointcloud: /*renderPointcloud*/ ctx[8]
	};

	if (/*predictions*/ ctx[4] !== void 0) {
		scatter_props.predictions = /*predictions*/ ctx[4];
	}

	scatter = new Scatter({ props: scatter_props });
	binding_callbacks.push(() => bind(scatter, "predictions", scatter_predictions_binding));

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(videocanvas.$$.fragment);
			t = space();
			create_component(scatter.$$.fragment);
			attr(div0, "class", "");
			attr(div1, "class", "flex w-full");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(videocanvas, div0, null);
			append(div1, t);
			mount_component(scatter, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const videocanvas_changes = {};
			if (dirty & /*video*/ 4) videocanvas_changes.video = /*video*/ ctx[2];

			if (!updating_predictions && dirty & /*predictions*/ 16) {
				updating_predictions = true;
				videocanvas_changes.predictions = /*predictions*/ ctx[4];
				add_flush_callback(() => updating_predictions = false);
			}

			videocanvas.$set(videocanvas_changes);
			const scatter_changes = {};

			if (!updating_predictions_1 && dirty & /*predictions*/ 16) {
				updating_predictions_1 = true;
				scatter_changes.predictions = /*predictions*/ ctx[4];
				add_flush_callback(() => updating_predictions_1 = false);
			}

			scatter.$set(scatter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(videocanvas.$$.fragment, local);
			transition_in(scatter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(videocanvas.$$.fragment, local);
			transition_out(scatter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			/*videocanvas_binding*/ ctx[13](null);
			destroy_component(videocanvas);
			destroy_component(scatter);
		}
	};
}

function create_fragment(ctx) {
	let div5;
	let div4;
	let t0;
	let div1;
	let div0;
	let t1;
	let div2;
	let backendchooser;
	let updating_backend;
	let t2;
	let div3;
	let cameravideo;
	let updating_video;
	let t3;
	let current;
	let if_block0 = /*info*/ ctx[6] && create_if_block_1(ctx);

	function backendchooser_backend_binding(value) {
		/*backendchooser_backend_binding*/ ctx[11].call(null, value);
	}

	let backendchooser_props = {
		renderPointcloud: /*renderPointcloud*/ ctx[8]
	};

	if (/*backend*/ ctx[3] !== void 0) {
		backendchooser_props.backend = /*backend*/ ctx[3];
	}

	backendchooser = new BackendChooser({ props: backendchooser_props });
	binding_callbacks.push(() => bind(backendchooser, "backend", backendchooser_backend_binding));

	function cameravideo_video_binding(value) {
		/*cameravideo_video_binding*/ ctx[12].call(null, value);
	}

	let cameravideo_props = {
		mobile: /*mobile*/ ctx[7],
		VIDEO_WIDTH,
		VIDEO_HEIGHT
	};

	if (/*video*/ ctx[2] !== void 0) {
		cameravideo_props.video = /*video*/ ctx[2];
	}

	cameravideo = new CameraVideo({ props: cameravideo_props });
	binding_callbacks.push(() => bind(cameravideo, "video", cameravideo_video_binding));
	cameravideo.$on("loadedmetadata", /*loadedmetadata*/ ctx[9]);
	let if_block1 = /*videoLoaded*/ ctx[5] && create_if_block(ctx);

	return {
		c() {
			div5 = element("div");
			div4 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = space();
			div2 = element("div");
			create_component(backendchooser.$$.fragment);
			t2 = space();
			div3 = element("div");
			create_component(cameravideo.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			attr(div0, "class", "bg-gray-500");
			attr(div1, "class", "pr-16");
			attr(div2, "class", "pr-16 bg-gray-500");
			attr(div3, "class", "w-20 h-20");
			attr(div4, "class", "absolute flex flex-wrap");
			attr(div5, "class", "bg-gray-200");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			if (if_block0) if_block0.m(div4, null);
			append(div4, t0);
			append(div4, div1);
			append(div1, div0);
			/*div0_binding*/ ctx[10](div0);
			append(div4, t1);
			append(div4, div2);
			mount_component(backendchooser, div2, null);
			append(div4, t2);
			append(div4, div3);
			mount_component(cameravideo, div3, null);
			append(div5, t3);
			if (if_block1) if_block1.m(div5, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*info*/ ctx[6]) if_block0.p(ctx, dirty);
			const backendchooser_changes = {};

			if (!updating_backend && dirty & /*backend*/ 8) {
				updating_backend = true;
				backendchooser_changes.backend = /*backend*/ ctx[3];
				add_flush_callback(() => updating_backend = false);
			}

			backendchooser.$set(backendchooser_changes);
			const cameravideo_changes = {};

			if (!updating_video && dirty & /*video*/ 4) {
				updating_video = true;
				cameravideo_changes.video = /*video*/ ctx[2];
				add_flush_callback(() => updating_video = false);
			}

			cameravideo.$set(cameravideo_changes);

			if (/*videoLoaded*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*videoLoaded*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div5, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(backendchooser.$$.fragment, local);
			transition_in(cameravideo.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(backendchooser.$$.fragment, local);
			transition_out(cameravideo.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			if (if_block0) if_block0.d();
			/*div0_binding*/ ctx[10](null);
			destroy_component(backendchooser);
			destroy_component(cameravideo);
			if (if_block1) if_block1.d();
		}
	};
}

const VIDEO_WIDTH = 640;
const VIDEO_HEIGHT = 500;

function isMobile() {
	const isAndroid = (/Android/i).test(navigator.userAgent);
	const isiOS = (/iPhone|iPad|iPod/i).test(navigator.userAgent);
	return isAndroid || isiOS;
}

function instance($$self, $$props, $$invalidate) {
	let statsContainer;
	let videoCanvas;
	let info;
	let video;
	tfjsWasm.setWasmPath(`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${version_wasm}/dist/tfjs-backend-wasm.wasm`);
	const mobile = isMobile();

	// Don't render the point cloud on mobile in order to maximize performance and
	// to avoid crowding limited screen space.
	const renderPointcloud = mobile === false;

	let backend = "webgl";
	let predictions = [];
	const state = { backend };

	if (renderPointcloud) {
		state.renderPointcloud = true;
	}

	let model;

	const landmarksRealTime = async video => {
		model = await handpose.load();
		const stats = new Stats();
		stats.showPanel(0);
		statsContainer.appendChild(stats.dom);

		async function frameLandmarks() {
			stats.begin();
			await videoCanvas.renderVideo();
			$$invalidate(4, predictions = await model.estimateHands(video));
			stats.end();
			requestAnimationFrame(frameLandmarks);
		}

		await frameLandmarks();
	};

	let videoLoaded = false;

	const loadedmetadata = async () => {
		$$invalidate(5, videoLoaded = true);
		await landmarksRealTime(video);
	};

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			statsContainer = $$value;
			$$invalidate(0, statsContainer);
		});
	}

	function backendchooser_backend_binding(value) {
		backend = value;
		$$invalidate(3, backend);
	}

	function cameravideo_video_binding(value) {
		video = value;
		$$invalidate(2, video);
	}

	function videocanvas_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			videoCanvas = $$value;
			$$invalidate(1, videoCanvas);
		});
	}

	function videocanvas_predictions_binding(value) {
		predictions = value;
		$$invalidate(4, predictions);
	}

	function scatter_predictions_binding(value) {
		predictions = value;
		$$invalidate(4, predictions);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*backend*/ 8) {
			$: if (backend) {
				tf.setBackend(backend);
			}
		}
	};

	return [
		statsContainer,
		videoCanvas,
		video,
		backend,
		predictions,
		videoLoaded,
		info,
		mobile,
		renderPointcloud,
		loadedmetadata,
		div0_binding,
		backendchooser_backend_binding,
		cameravideo_video_binding,
		videocanvas_binding,
		videocanvas_predictions_binding,
		scatter_predictions_binding
	];
}

class Handpose extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Handpose;